#+TITLE: Leetcode Notes


* [#A] approaches
** TODO [[https://leetcode.com/tag/dynamic-programming/][dynamic programming]]

*** [[https://leetcode.com/problems/remove-boxes/][546 remove-boxes]] (extra-state DP)

This is very good problem. This extends simple DP with
1. two dp variables, i and j
2. one more state variable k

Reference: [[https://leetcode.com/problems/remove-boxes/discuss/101310/Java-top-down-and-bottom-up-DP-solutions][A good post]].

See the following graph:

#+ATTR_HTML: :style max-width:100%
[[./assets/a.png]]

The first case, directly consume the left =k+l= a's, and DP on the rest:

$$T_l(i,j,k) = T(i+l,j,0) + (k+l)^2$$

For each m, consume =[i+l:m-1]=, and DP on rest:

$$T_m(i,j,k) = T(i+l,m-1,0) + T(m,j,k+l)$$

The l is computed by:

#+BEGIN_SRC python
def get_l(i, j):
    l = 1
    while l <= j-i and boxes[i+l] == boxes[i]:
        l += 1
    return l
#+END_SRC

The list of m is computed by:
#+BEGIN_SRC python
def get_ms(i, j, l):
    res = []
    for m in range(i+l,j+1):
        if boxes[m] == boxes[i]:
            res.append(m)
    return res
#+END_SRC

The full DP logic:

#+BEGIN_SRC python
n = len(boxes)
mem = np.zeros((n,n,n), int)
def dp(i, j, k):
    # the max point of T[i:j]
    if i > j: return 0
    if i == j: return (k+1)*(k+1)
    if mem[i,j,k] > 0: return mem[i,j,k]

    l = get_l(i, j)
    res = dp(i+l, j, 0) + (k+l) ** 2

    ms = get_ms(i, j, l)
    for m in ms:
        cand = dp(i+l,m-1,0) + dp(m,j,k+l)
        if cand > res: res = cand

    mem[i,j,k] = res
    return res
# the final output:
dp(0, n-1, 0)
#+END_SRC

Some tests:
#+BEGIN_SRC python
def test():
    # 23
    removeBoxes([1, 3, 2, 2, 2, 3, 4, 3, 1])
    # 9
    removeBoxes([1,1,1])
#+END_SRC

*** [[https://leetcode.com/problems/burst-balloons/][312 burst-balloons]] (complement's DP)

This related, and contains not only one k, but two ks for left and right.

See [[https://leetcode.com/problems/burst-balloons/discuss/76228/][this post]] and [[https://leetcode.com/problems/burst-balloons/discuss/76229/][this]].

This actually /much easier/, and not related to remove boxes at all. But there's
one tricky thing to notice: =dp(i,j)= should indicates the maximum coins we get
when we *burst all bolloons* in =[i:j]=.

#+BEGIN_SRC python
def maxCoins(self, nums: List[int]) -> int:
    n = len(nums)
    mem = np.zeros((n, n), int)
    def coins(i, j, k):
        return nums[k] * (nums[i] if i>=0 else 1) * (nums[j] if j<n else 1)
    def dp(i, j):
        # the max coins we get when we burst all bolloons [i:j]
        if i > j: return 0
        if i == j: return coins(i-1,j+1,i)
        if mem[i,j] > 0: return mem[i,j]

        cands = []
        for k in range(i,j+1):
            cand = dp(i, k-1) + dp(k+1, j) + coins(i-1, j+1, k)
            cands.append(cand)
        res = max(cands)

        mem[i,j] = res
        return res
    return dp(0, n-1)

# 167
maxCoins([3,1,5,8])
#+END_SRC

*** [[https://leetcode.com/problems/super-egg-drop/][887 egg drop]] (complement's DP)
See the first discussion in [[https://leetcode.com/problems/super-egg-drop/discuss/158974][this post]].  This looks like a number trick, but
turns out not. Looks like we have to use DP. There are several tricks:
1. Work on *=dp(M,K)= instead of =dp(N,K)=*. I.e. in M moves and K eggs, what is
   the largest number N of floors we can check.
2. the dp equation is tricky:

#+begin_example
dp(m,k) = dp(m-1,k-1) + dp(m-1,k) + 1
#+end_example

We first try =dp(m-1,k-1)=, i.e. one less move, one less eggs, so that we have
room for next experiment. So, the first floor we try is =dp(m-1,k-1)+1=. If it
breaks, we use check the lower floors with =dp(m-1,k-1)=. If it doesn't break,
we still have =k= eggs, and we can check =dp(m-1,k)= more. Thus the equation.

Reference to [[https://leetcode.com/problems/number-of-music-playlists/discuss/180338][this post]].

#+BEGIN_SRC python
import math
import numpy as np
class Solution:
    def superEggDrop(self, K: int, N: int) -> int:
        mem = np.zeros((N+1,K+1), int)
        def dp(m,k):
            if m==0 or k==0: return 0
            if m==1 and k==1: return 1
            if mem[m,k] > 0: return mem[m,k]
            res = dp(m-1, k-1) + dp(m-1,k) + 1
            mem[m,k] = res
            return res
        for m in range(N+1):
            if dp(m,K) >= N:
                return m
        assert False

Solution().superEggDrop(1,2)    # 2
Solution().superEggDrop(2,6)    # 3
Solution().superEggDrop(3,14)   # 4
Solution().superEggDrop(2,2)    # 2
#+END_SRC


*** [[https://leetcode.com/problems/number-of-music-playlists/][(920) number of playlists]]

The second requirement is ambigious. Other than that, the DP equation is pretty
regular. However, two things worth noticing:
1. the initial condition
2. the recursion version is so much slower

#+BEGIN_SRC python
class Solution:
    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:
        mod = 10 ** 9 + 7
        mem = np.zeros((N+1, L+1), int)
        def dp(n, l):
            if l == 0 and n == 0: return 1
            if n == 0 and l > 0: return 0
            if l == 0 and n > 0: return 0
            if mem[n,l] >0: return mem[n,l]
            res = dp(n-1, l-1) * n + dp(n, l-1) * max(n-K, 0)
            mem[n,l] = res % mod
            return mem[n,l]
        # return dp(N,L) % mod
        #
        # ok, this is much faster!!
        mem[0,0] = 1
        for ni in range(1,N+1):
            for li in range(ni,L+1):
                mem[ni,li] = (mem[ni-1,li-1] * ni + mem[ni,li-1] * max(ni-K,0)) % mod
        return mem[N,L]

Solution().numMusicPlaylists(3,3,1)  # 6
Solution().numMusicPlaylists(2,3,0)  # 6
Solution().numMusicPlaylists(2,3,1)  # 2
Solution().numMusicPlaylists(1,1,0)  # 1

Solution().numMusicPlaylists(16, 16, 4)  # 789741546
Solution().numMusicPlaylists(25, 28, 5)  # 906368459
#+END_SRC


** TODO [[https://leetcode.com/tag/recursion/][recursion]]
** TODO [[https://leetcode.com/tag/divide-and-conquer/][divide and conquer]]

* [#A] special problems
** Number theory
*** [[https://leetcode.com/problems/largest-multiple-of-three/][1363. Largest Multiple of Three]]

A typical mod-of-3 problem. The trick is to =reduce_147= (1 mod 3) or
=reduce_258= (2 mod 3) either 1 or 2 times.

#+BEGIN_SRC python
class Solution:
    def largestMultipleOfThree(self, digits: List[int]) -> str:
        digits = sorted(digits, reverse=True)
        d = {}
        for i in range(10):
            d[i] = 0
        for i in digits:
            d[i] += 1
        def construct():
            res = ''
            for i in range(9,-1,-1):
                res += str(i) * d[i]
            if not res: return res
            return str(int(res))
        def reduce_258():
            if d[2] >= 1: d[2] -= 1
            elif d[5] >= 1: d[5] -= 1
            elif d[8] >= 1: d[8] -= 1
            else: assert False
        def reduce_147():
            if d[1] >= 1: d[1] -= 1
            elif d[4] >= 1: d[4] -= 1
            elif d[7] >= 1: d[7] -= 1
            else: assert False
        if sum(digits) % 3 == 0:
            return construct()
        if sum(digits) % 3 == 1:
            if d[1] + d[4] + d[7] >= 1:
                reduce_147()
                return construct()
            elif d[2] + d[5] + d[8] >= 2:
                reduce_258()
                reduce_258()
                return construct()
            else: return ''
        if sum(digits) % 3 == 2:
            if d[2] + d[5] + d[8] >= 1:
                reduce_258()
                return construct()
            elif d[1] + d[4] + d[7] >= 2:
                reduce_147()
                reduce_147()
                return construct()
            else: return ''
#+END_SRC


** TODO [#A] [[https://leetcode.com/tag/bit-manipulation/][bit manipulation]]


** TODO [[https://leetcode.com/tag/union-find/][union find (29)]]
This looks interesting

** TODO [[https://leetcode.com/tag/two-pointers/][two pointers]]
(HEBI: ??) but looks interesting

** TODO [[https://leetcode.com/tag/sliding-window/][sliding window]]
Looks like sequence matching

* random tricks

integer to binary string: =bin(324)=

sort with multiple keys:
#+BEGIN_SRC python
sorted([0,1,2,3,4,5,6,7,8], key=lambda x: (x%3, x))
#+END_SRC

** string functions

#+BEGIN_SRC python
'hello'.count('l')
'hello'.index('e')
#+END_SRC



* data structures
** linear
*** stack
*** linked list
*** queue

** hash table
*** ordered map

** TODO [#A] tree

**** [[https://leetcode.com/problems/validate-binary-tree-nodes/][1361. Validate Binary Tree Nodes]]

This is a pretty typical problem. The tree is valid if there's no (not
necessarily directed) cycle. To do that, traverse the tree from any given point,
and record two sets:
- =stop=: current active given point. Other traversal should stop here.
- =done=: all visited nodes except the current active stop points.

#+BEGIN_SRC python
class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
        done = set()
        stop = set()
        self.flag = True
        def visit(item):
            if item in done:
                self.flag = False
                return
            if item in stop:
                stop.remove(item)
            done.add(item)
        def travel(item):
            if item == -1: return
            l = leftChild[item]
            r = rightChild[item]
            visit(item)
            if self.flag:
                travel(l)
                travel(r)
        for i in range(n):
            if not i in done and not i in stop:
                travel(i)
                stop.add(i)
                done.remove(i)
        # count stop
        if not self.flag: return False
        if len(stop) > 1: return False
        if len(done) != n-1: return False
        return True
#+END_SRC




*** trie
*** heap
*** segment tree

** TODO [#A] graph
