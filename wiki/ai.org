#+TITLE: Artificial Intelligence

* Graphical Model

/Undirected graphical model/ is also called /Markov random field/ or
/Markov network/. /Directed graphical model/ is called /Bayesian
network/.

Two types of tasks are popular in the literature. /Learning/ refers to
the estimation of edge parameters from data. /Inference/ refers to the
computation of marginal vertex probabilities and expectations from
their joint distribution.

Some graph theory background. For undirected graph, two nodes are
/adjacent/ if there is an edge joining them, denoted as $X \sim Y$. A
/path/ is a set of vertices that are adjacent sequentially. A
/complete graph/ is a graph where every pair of vertices is joined by
an edge. A /subgraph/ is a subset of vertices together with their
edges. A /clique/ is a complete subgraph. It is called /maximal/ if it
is a clique and no other vertices can be added to it and still yield a
clique.

Some probability background.  /Prior/ is also called /unconditional
probabilities/ or /prior probabilities/.  /Posterior/ is also called
/conditional probability/ or /posterior probability/.  /Evidence/ is
the results observed, should be synonymous for observation.
/Probability distribution/ is the name for discrete random variables,
/probability density function/ is used for continuous random
variables, because the vector is infinite.  /Joint probability
distribution/ is the P for two variables with some interaction.  /full
joint probability distribution/ is the joint distribution for all
variables.  /marginalization/ is also called /summing out/, because it
sums the conditional probabilities. The process of computing the
unconditional probability, aka marginal probability.  /Probabilistic
inference/ refers to the computation of posterior probabilities given
evidence.

Product rule

$$P(a \wedge b) = P(a|b) P(b)$$

inclusion-exclusion principle

$$P(a\vee b) = P(a) + P(b) - P(a \wedge b)$$

Bayes rule:

$$P(b|a) = \frac{P(a|b)P(b)}{P(a)}$$

conditioning rule:

$$P(Y) = \sum_{z} P(Y|z)P(z)$$

(absolute) independence

$$P(X|Y)=P(X)$$

conditional independence:

$$P(X,Y|Z) = P(X|Z) P(Y|Z)$$

Gausion (normal) distribution: $N(\mu, \sigma^2)(x)$ has the mean
$\mu$ and the variance $\sigma^2$.


** Markov Network

In a Markov graph, the absence of an edge implies that the
corresponding random variables are conditionally independent given the
variables given /all/ other variables. This is also known as /pairwise
Markov independence of G/:

$$ \neg X \sim Y \Leftrightarrow X \bot Y | rest$$

A,B,C are subgraphs. C is said to /separate/ A and B if every path
between A and B intersects a node in C. These separators have nice
property that they break the graph into conditionally independent
pieces, this is known as /global Markov properties of G/:

#+begin_quote
if C separates A and B, then $A \bot B | C$
#+end_quote

The pairwise and global Markov properties of a graph are equivalent.

** Bayesian Network

#+begin_quote
Node X is conditionally independent of all other nodes in the network,
given its markov blanket. (parents, children, and children's parents).
#+end_quote

#+begin_quote
Node X is conditionally independent of its non-descendants given its
parent.
#+end_quote

/Conditional probability table (CPT)/ is a table in which each row
shows a conditional probability.

For continuous variables, the Bayes needs to do something.  Of course
we can do discretization, but the precision is lost.  One common
solution is to define standard families of probability density
functions, with a finite number of parameters, the most commonly used
is the Gausion (normal) distribution.  Another solution is
non-parameter one.  A network with both discrete and continuous
variables is called hybrid Bayesian network.

* Search Algorithm

** Branch & Bound algorithm
The problem is to minimize a function f(x) of variables $x_1,...,x_n$
over a region of feasible solutions S.

$$min_{x\in S} f(x)$$

The solutions state space S is formed as a /rooted tree/.  The key to
this algorithm is the efficient estimation of lower or upper bound.
The problem is NP-hard.

f(x) is called /objective function/.  a function g(x) is the lower
bound, defines on S with the property that g(x) \le f(x) for all x \in
S.

The algorithm:
1. use a heuristic, find a solution x_h. Store its value B \leftarrow
   f(x_h). B is the global best solution so far. If no solution found,
   init B to \infty
2. init a queue with the root ??
3. loop until the queue is empty
  1. take a node N off the queue
  2. if N represents a single candidate solution x (N is a leaf?) and
     f(x) < B, then B = f(x).
  3. Else, branch on N to produce new nodes $N_1,...,N_i$. For each
     new node:
    1. if g(N_i) > B, do nothing.
    2. else store N_i onto the queue

Intuitively in natural language description, the problem is to
minimize (or maximize) the objective function f(x) over $x_1,..,x_n$.
The feasible solution search state space is a tree.  The initial best
known value is B=f(x_h) or \infty if no solution x_h found by
heuristic.  From the root, everytime branch into two or more branches.
For those branches, compute the lower bound.  If the lower bound is
larger than current best, then do not need to go into these branch.
Thus we can eliminate the computation of this branch.

The assumption is the lower (or upper) bound is efficient to compute.
Every time branch may or may not overlap, as long as the optimal
solution is inside at least one branch.

** A* algorithm
The problem is, from an initial node, find the least-cost path to one
/goal node/ (out of one or more possible goals).

$$f(n) = g(n) + h(n)$$

where n is current node.
- f(n) is the cost function.
- g(n) is the known cost of getting from initial node to n.
- h(n) is a heuristic esitimate of the cost to get from n to any goal
  node.
- h(n) must be /admissible/, i.e. it never overestimates the actual
  cost, i.e. it is always less then or equal to the actual cost.

The algorithm: from initial node, it maintains a priority queue of
nodes.  The lower $f(n)$, the higher its priority.  At each step, the
node with lowest $f(x)$ is removed, and $f$ and $g$ of its neighbors
are updated.  Add these neighbors into the queue.  The algorithm
terminates when one goal node has a lower $f$ value than any node in
the queue.

Intuitively, from the start point, try all neighbors, and remember
both the actual cost from the initial node, and the estimate from this
node to one goal.  Repeat trying neighbors until reach goal nodes.
Stop when the goal nodes has the lowest cost function value.


** local search
*** hill climbing
Find an initial solution, which is much worse than optimal one.
Attempts to find a better solution by incrementally changing a
/single/ element of the solution.  Repeat until no better can be
found.
*** simulated annealing(SA)
Accepting worse solutions is a fundamental property of metaheuristics
because it allows for a more extensive search for the optimal
solution.

This is essentially the key for SA: have probability to accept a move
to worse state.  A move from state s0 to s1 means go to that solution,
and then do iteration.  Stop until the energy is small enough or total
budget runs out.  The goal is to make the energy of the system
smallest.

P(e,e',T) is /acceptance probability function/, which decides whether
to move from e to e'.  Well, if e'<e, then it should be 1, so that
always goes to smaller state if found.  But this is not required.

*** gradient descent
Go alone the decrease of the gradient.

* Similarity metrics
/Jaccard index/, also known as the /Jaccard similarity coefficient/,
compares two sets, A and B.

$J(A,B) = \frac{A \cap B}{A \cup B}$

/Cosine similarity/ is most widely used, typically the terms are
weighted with /TF-IDF/. /term frequency–inverse document frequency
(TF-IDF)/ is used in information retrieval. It is a numerical
statistic that is intended to reflect how important a word is to a
document.
- /term frequency/:: the number of times a term occurs in a
  document. E.g. "good" appears 3 times.
- /inverse document frequency/:: this is to fix the word "the" appears
  so often and not that useful.  $idf(t,D) = log \frac{N}{|\{d \in D :
  t \in d\}}$ Meaning the total number of documents, divided by the
  documents that contains the word =t=.
- /term frequency–inverse document frequency/:: tfidf(t, d) = tf(t,
  d) * idf(t, D)

Example:

| term    | doc 1 | doc 2 |
|---------+-------+-------|
| this    |     1 |     1 |
| is      |     1 |     1 |
| a       |     2 |       |
| sample  |     1 |       |
| another |       |     2 |
| example |       |     3 |

- tf("this", d1) = 1/5
- tf("this", d2) = 1/7
- idf("this", D) = log(2/2) = 0
- tfidf("this", d1) = 1/5 * 0 = 0
- tfidf("this", d2) = 1/7 * 0 = 0

Both the tfidf is 0, meaning "this" is not very informative.

- tf("example", d1) = 0 / 5
- tf("example", d2) = 3/7
- idf("example", D) = log(2/1) = 0.3
- tfidf("example", d1) = 0 / 5 * 0.3 = 0
- tfidf("example", d2) = 3 / 7 * 0.3 = 0.13
